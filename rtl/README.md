## Description
This directory contains the RTL verilog models of the systolic arrays, the equivalent verilated C++ designs and the Gemmini interface adapter library to simulate the Mesh unit. The structure of this directory is as follows:

1. [`designs`](./designs): The verilog sample of the Gemmini Mesh unit, in the folder `designs`. This must include, for each config:
    - Mesh.sv file: The top level Mesh module from Chipyard;
    - Tile.sv file: Contains PE units. Currently, all sample configs contain a single PE per tile;
    - PE.sv: Takes the tile inputs, orchestrates how inputs are stored, mapped to the MAC unit, and compute the outputs;
    - MacUnit.sv: the MAC unit.

2. The [`verilated`](./verilated) folder: this contains the C++ verilated designs. After you run `./verilate.sh <config>`, a new folder is generated for each design;

3. The script [`extract_pointers.py`](extract_pointers.py): this is a parser script that reads the Mesh.sv input file and extracts every input/output and control register associated with each PE in the Mesh unit. This parser emmits C++ vector declarations, containing pointers to every PE signal. These declarations must be stored in `lib/Gemmini/headers/gemmini-pointers/<os or ws>/<CONFIG>.cc`;

3. The [`lib/Gemmini`](./lib/Gemmini): the main C++ interface adapters to simulate the Mesh unit (as described in your paper). This interface sets the inputs to the simulated Mesh unit and orchestrates the control signals to perform basic systolic operations: input preloading, input streaming through the PEs, and flushing the outputs from the PE accumulators (OS mode).

## Porting new configurations
Many Gemmini configuration examples are provided in `rtl/designs`. These configurations are instantiated in [`pytorch/src/gemmini/gemmini_config.py`](../pytorch/src/gemmini/gemmini_config.py). For injection experiments, configs are selected through the `$gemmini_config_key` experiment variable (in your experiment scripts) to index the specific key. 

Adding new Gemmini configurations requires generating the verilog code with the [Chipyard](https://chipyard.readthedocs.io/en/latest/) framework. Follow the instructions they provide. After the hardware generation, use the design examples provided in the `rtl/designs` folder. Follow the same pattern as shown in the examples. To port a new configuration, let's say `Systamagotchi`, do:

1. Copy the verilog modules generated by Chipyard (Mesh.sv and the others as seen in the examples) to your design folder: `rtl/designs/Systamagotchi`;

2. Run:
```
cd rtl
./verilate.sh Systamagotchi 
```
This will generate the C++ representation of the verilog design in `rtl/designs/verilated/Systamagotchi`

3. Extract the Mesh pointers: from the `rtl` folder, run:
```
python extract_pointers.py designs/Systamagotchi/Mesh.sv lib/Gemmini/headers/gemmini-pointers/<os or ws>/Systamagotchi.cc
```
The cc output file will contain the extracted pointers to the PE signals. Note that you have to choose one of two folders: **os** or **ws**, according to the array execution mode of `Systamagotchi` (Output Stationary or Weight Stationary);

4. Create a new config header file `rtl/lib/Gemmini/headers/configs/<os or ws/Systamagotchi.h`: Configure this header by including the path of the verilated design. Follow the pattern of the other examples in the folder: just copy and paste an existing config file, rename it to `Systamagotchi.h`. Open the file and replace the included paths with `Systamagotchi`. Define the DIM macro and data types fitting your design;

6. Port the new configuration in the file [`pytorch/src/gemmini/gemmini_config.py`](../pytorch/src/gemmini/gemmini_config.py);

7. Test the config: set the new config in [`pytorch/tests/test_gemmini.py`](../pytorch/tests/test_gemmini.py) with `CONFIG_KEY="Systamagotchi"`, then:
```
cd pytorch
python tests/test_gemmini.py
```